# Завойских Евгения, ИУ7-13Б
# Вычисление приближенного значения интеграла методом правых прямоугольников и методом Буля
# с заданным числом разбиений, вывод таблицы с полученными значениями
# Для менее точного метода определить количество разбиений,
# для которого интеграл вычислен с заданной точностью
# Вычислить для этого метода абсолютную и относительную погрешности интегрирования


# Функция, возвращающая число, если переданная строка содержит число
def get_num_or_str(string):
    if string.isdigit() or (string[0] == '-' and string[1:].isdigit()):  # Строка содержит целое число
       return int(string)  # Возвращаем целое число из строки
    else:
        try:
            f = float(string)  # Пробуем преобразовать к вещественному
            return f
        except ValueError:  # Строка не содержит вещественное число
            return string  #  Возвращаем строку

# Функция для вычисление значения подынтегральной функции
def f(x):
    y = x * x / 10
    return y

# Функция для вычисления значения первообразной
def F(x):
    y = x ** 3 / 30
    return y

# Функция для вычисления значения интеграла методом правых прямоугольников
def right_rects(n):
    h = (b - a) / n  # Шаг разбиения заданного интервала
    x = a + h  # Значение первой точки x1
    s = 0  # Интегральная сумма

    # Перебер всех точек интервала включая крайнюю с шагом разбиения
    while x <= b:
        s += f(x)
        x += h

    s *= h
    return s

# Функция для вычисления значения интеграла методом Буля
def boole(n):
    if n % 4 != 0:  # Нельзя посчитать интеграл
        return None
    else:
        h = (b - a) / n  # Шаг разбиения заданного интервала
        s = 7 * (f(a) + f(b))  # Интегральная сумма
        x = a + h  # Значение второй точки x1

        # Перебер точек интервала не включая крайние с шагом разбиения
        for i in range(1, n):
            if i % 2 != 0:
                s += 32 * f(x)
            elif i % 4 == 0:
                s += 14 * f(x)
            else:
                s += 12 * f(x)
            x += h

        s *= 2 * h / 45
        return s


a = get_num_or_str(input('Введите начало отрезка интегрирования: '))
b = get_num_or_str(input('Введите конец отрезка интегрирования: '))
while type(a) == str or type(b) == str or a > b:  # Пока концы отрезка не числа или a > b
    a = get_num_or_str(input('Введите начало отрезка интегрирования: '))
    b = get_num_or_str(input('Введите конец отрезка интегрирования: '))

n1 = get_num_or_str(input('Введите количество участков разбиения n1: '))
n2 = get_num_or_str(input('Введите количество участков разбиения n2: '))
while type(n1) != int or type(n2) != int or n1 <= 0 or n2 <= 0:  # Пока числа разбиений <= 0 или не int
    n1 = get_num_or_str(input('Введите количество участков разбиения n1: '))
    n2 = get_num_or_str(input('Введите количество участков разбиения n2: '))
n1, n2 = min(n1, n2), max(n1, n2)  # Второе число разбиений больше первого

i1 = right_rects(n1)  # Вычисление интеграла методом правых прямоугольников с n1 разбиением
i2 = right_rects(n2)  # Вычисление интеграла методом правых прямоугольников с n2 разбиением
i3 = boole(n1)  # Вычисление интеграла методом Буля с n1 разбиением
i4 = boole(n2)  # Вычисление интеграла методом Буля с n2 разбиением

w = 24  # Ширина столбца таблицы
# Вывод таблицы
print('-' * w + '+' + '-' * w + '+' + '-' * w)
print('Метод'.rjust(w // 2, ' ').ljust(w, ' '), end='|')  # Вывод заголовка первого столбца
print(('n1 = %d' % n1).rjust(w // 2, ' ').ljust(w, ' '), end='|')  # Вывод заголовка второго столбца
print(('n2 = %d' % n2).rjust(w // 2, ' '))  # Вывод заголовка третьего столбца
print('-' * w + '+' + '-' * w + '+' + '-' * w)

print('Правых прямоугольников'.rjust(w // 2, ' ').ljust(w, ' '), end='|')  # Вывод названия метода
print(str('{:.7g}'.format(i1)).rjust(w // 2, ' ').ljust(w, ' '), end='|')  # Вывод первого значения интеграла
print(str('{:.7g}'.format(i2)).rjust(w // 2, ' '))  # Вывод второго значения интеграла
print('-' * w + '+' + '-' * w + '+' + '-' * w)

print('Буля'.rjust(w // 2, ' ').ljust(w, ' '), end='|')  # Вывод названия метода

if i3 == None:  # Для n1 числа разбиений метод Буля не работает
    s3 = '----'
else:  # Для n1 числа разбиений метод работает
    s3 = '{:.7g}'.format(i3)
print(s3.rjust(w // 2, ' ').ljust(w, ' '), end='|')  # Вывод первого значения интеграла

if i4 == None:  # Для n2 числа разбиений метод Буля не работает
    s4 = '----'
else:  # Для n2 числа разбиений метод работает
    s4 = '{:.7g}'.format(i4)
print(s4.rjust(w // 2, ' '))  # Вывод второго значения интеграла
print('-' * w + '+' + '-' * w + '+' + '-' * w)


eps = get_num_or_str(input('Введите точность: '))  # Точность вычислений
while type(eps) == str or eps < 0:  # Пока точность не будет числом >= 0
    eps = get_num_or_str(input('Введите точность: '))

integral = F(b) - F(a)  # Точное значение интеграла на заданном отрезке
print('Точное значение интеграла на заданном отрезке = {:.7g}'.format(integral))

# Метод Буля не работает на количестве разбиений n2, смотрим на n1
if i4 == None:
    i4 = i3
    i2 = i1

if i4 == None:  # Метод Буля не работает на количестве разбиений n1
    print('Метод Буля на заданных количествах разбиений не работает, смотрим метод правых прямоугольников')
elif abs(integral - i2) >= abs(integral - i4):  #  Метод правых прямоугольников менее точен
    print('Метод правых прямоугольников менее точен')

if i4 == None or abs(integral - i2) >= abs(integral - i4):
    n = 1  # Количество разбиений для получения значения с заданной точностью
    while abs(right_rects(n) - right_rects(2 * n)) > eps:  # Пока не достигнута указанная точность
        n *= 2
    i_n = right_rects(n)  # Значение интеграла с заданной точностью

    print('Значение интеграла этим методом с заданной точностью = {:.7g}'.format(i_n))
    print('Количество разбиений при этом = %d' % n)

    absol = abs(integral - i_n)  # Абсолютная погрешность вычислений
    rel = abs(absol / integral)  # Относительная погрешность вычислений

    print('Абсолютная погрешность вычислений этого метода = {:.7g}'.format(absol))
    print('Относительная погрешность вычислений этого метода = {:.7g}'.format(rel))

else:  # Метод Буля менее точен
    print('Метод Буля менее точен')

    n = 4  # Количество разбиений для получения значения с заданной точностью
    while abs(boole(n) - boole(2 * n)) > eps:  # Пока не достигнута указанная точность
        n *= 2
    i_n = boole(n)  # Значение интеграла с заданной точностью

    print('Значение интеграла этим методом с заданной точностью = {:.7g}'.format(i_n))
    print('Количество разбиений при этом = %d' % n)

    absol = abs(integral - i_n)  # Абсолютная погрешность вычислений
    rel = abs(absol / integral)  # Относительная погрешность вычислений

    print('Абсолютная погрешность вычислений этого метода = {:.7g}'.format(absol))
    print('Относительная погрешность вычислений этого метода = {:.7g}'.format(rel))





